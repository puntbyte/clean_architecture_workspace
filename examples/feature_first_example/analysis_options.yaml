# feature_first_example/analysis_options.yaml

formatter:
  page_width: 100

analyzer:
  plugins:
    - custom_lint
  language:
    strict-casts: true
    strict-inference: true
    strict-raw-types: true

custom_lint:
  rules:
    # --- ENABLE ALL LINT RULES ---
    # Purity & Responsibility Rules
    - disallow_model_in_domain: true
    - disallow_entity_in_data_source: true
    - disallow_repository_in_presentation: true
    - disallow_model_return_from_repository: true
    - disallow_use_case_in_widget: true
    - disallow_flutter_in_domain: true
    - disallow_public_members_in_implementation: true
    - disallow_dependency_instantiation: true
    - disallow_service_locator: true

    # Contract & Inheritance Rules
    - enforce_model_to_entity_mapping: true
    - enforce_model_inherits_entity: true
    - enforce_repository_contract: true
    - enforce_use_case_contract: true
    - enforce_entity_contract: true
    - enforce_repository_implementation_contract: true
    - enforce_custom_inheritance: true # Generic engine for custom rules

    # Dependency & Structure Rules
    - enforce_layer_independence: true
    - enforce_abstract_data_source_dependency: true
    - enforce_abstract_repository_dependency: true
    - enforce_file_and_folder_location: true

    # Type Safety & Error Handling Rules
    - enforce_type_safety: true
    - disallow_throwing_from_repository: true
    - enforce_try_catch_in_repository: true
    - enforce_exception_on_data_source: true

    # Naming Convention Rules
    - enforce_naming_conventions: true
    - enforce_semantic_naming: true

    # Code Generation Rule
    - missing_use_case: true

    # --- SHARED CONFIGURATION BLOCK ---
    - clean_architecture:
      # [Section 1] This single block now defines the entire high-level project structure.
      module_definitions:
        type: 'feature_first' # or 'layer_first'
        core: 'core'
        features: 'features'
        # layers can be used for both feature_first and layer_first naming.
        # all layer components accept a single string or a list of strings.
        layers:
          domain: 'domain'
          data: 'data'
          presentation: 'presentation'

      # [Section 2] Defines the directory names for each architectural component.
      # Can be a single string or a list of strings.
      # all layer components accept a single string or a list of strings.
      layer_definitions:
        domain:
          entity: 'entities'
          contract: 'contracts'
          usecase: 'usecases'
        data:
          model: 'models'
          repository: 'repositories'
          source: 'sources'
        presentation:
          page: 'pages'
          widget: 'widgets'
          manager: [ 'managers', 'bloc', 'cubit' ]

      # A list of custom, user-defined inheritance rules, enforced by `enforce_inheritance`.
      # Core rules (Entity, Repository, UseCase) are handled by their own lints but can be overridden here.
      inheritances:
        # Overriding the default Entity contract to user defined.
        - on: 'entity'
          required:
            name: 'Entity'
            import: 'package:example/core/entity/entity.dart'

        # Example of overriding the default UseCase contract.
        - on: 'usecase'
          required:
            - name: 'MyBaseUseCase'
              import: 'package:my_core/my_core.dart'
            - name: 'MyOtherUseCase'
              import: 'package:my_core/my_core.dart'

        # Example of a suggested inheritance rule.
        - on: 'manager'
          allowed:
            name: 'Bloc'
            import: 'package:bloc/bloc.dart'

        # We can use both `suggested` and `forbidden` in a single rule for widget.
        - on: 'widget'
          allowed:
            name: 'HookWidget'
            import: 'package:flutter_hooks/flutter_hooks.dart'

          forbidden:
            name: 'StatefulWidget'
            import: 'package:flutter/widgets.dart'

      # in all configurations `on` can accept a single string or a list of strings.

      # [Section 3] Defines syntactic (`pattern`/`antipattern`) and semantic (`grammar`)
      # naming rules.
      naming_conventions:
        - on: entity
          pattern: '{{name}}'
          antipattern: '{{name}}Entity'
        - on: model
          pattern: '{{name}}Model'
          grammar: '{{noun.phrase}}Model'
        - on: usecase
          pattern: '{{name}}'
          antipattern: '{{name}}Use(C|c)ase'
          grammar: '{{verb.present}}{{noun.phrase}}'
        - on: usecase.parameter
          pattern: '_{{name}}Param'

        - on: source.interface
          pattern: '{{name}}DataSource'
        - on: source.implementation
          pattern: 'Default{{name}}DataSource'
        - on: repository.interface
          pattern: '{{name}}Repository'
        - on: repository.implementation
          pattern: '{{kind}}{{name}}Repository'

        - on: manager
          pattern: '{{name}}(Bloc|Cubit|Manager)'
          grammar: '{{noun.phrase}}(Bloc|Cubit|Manager)'
        - on: event.interface
          pattern: '{{name}}Event'
          grammar: '{{noun.phrase}}Event'
        - on: event.implementation
          pattern: '{{name}}'
          grammar: '{{subject}}{{noun.phrase}}?{{verb.past}}'
        - on: state.interface
          pattern: '{{name}}State'
          grammar: '{{noun.singular}}State'
        - on: state.implementation
          pattern: '{{name}}'
          grammar: '{{subject}}({{adjective}}|{{verb.gerund}}|{{verb.past}})'

      # A unified list of rules to enforce strong types and migrate away from unsafe primitives.
      type_safeties:
        # Rule 1: Enforce FutureEither on return types.
        - on: [ 'usecase', 'contract' ]
          returns:
            unsafe_type: 'Future'
            safe_type: 'FutureEither'
            import: 'package:example/core/utils/types.dart'

        # Rule 2: Enforce IntId for integer `id` parameters in contracts.
        - on: 'contract'
          parameters:
            - unsafe_type: 'int'
              identifier: 'id'
              safe_type: 'IntId'
              import: 'package:example/core/utils/types.dart'

            - unsafe_type: 'String'
              identifier: 'id'
              safe_type: 'StringId'
              import: 'package:example/core/utils/types.dart'

      # A list of rules to enforce the presence/absence of annotations on classes.
      # Enforced by the `enforce_annotations` lint. Also used by code generators.
      # annotations name do not have to have `@` prefix because annotations always start with @
      # annotations name do not have to have `()` suffix because they may have parameters or named
      # constructor.
      annotations:
        - on: 'entity'
          forbidden:
            name: [ 'Injectable', 'LazySingleton' ]

        - on: 'usecase'
          required:
            name: 'Injectable'
            import: 'package:injectable/injectable.dart'

        - on: 'repository'
          required:
            - name: 'LazySingleton'
              import: 'package:injectable/injectable.dart'
          allowed:
            name: 'WithCache'
            import: 'package:cached_annotation/cached_annotation.dart'

        - on: 'model'
          allowed:
            - name: 'freezed'
              import: 'package:freezed_annotation/freezed_annotation.dart'
            - name: 'MappableClass'
              import: 'package:dart_mappable/dart_mappable.dart'

      # Configuration for service-related lints.
      services:
        service_locator:
          # Configures the `disallow_service_locator` lint.
          name: ['getIt', 'locator', 'sl']